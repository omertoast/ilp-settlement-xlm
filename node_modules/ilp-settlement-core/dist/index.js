"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const bignumber_js_1 = require("bignumber.js");
const body_parser_1 = __importDefault(require("body-parser"));
const debug_1 = __importDefault(require("debug"));
const express_1 = __importDefault(require("express"));
const v4_1 = __importDefault(require("uuid/v4"));
const controllers_1 = require("./controllers");
const store_1 = require("./store");
const quantity_1 = require("./utils/quantity");
const retry_1 = require("./utils/retry");
const memory_1 = require("./store/memory");
exports.createMemoryStore = memory_1.createMemoryStore;
const redis_1 = require("./store/redis");
exports.connectRedis = redis_1.connectRedis;
const log = debug_1.default('settlement-core');
exports.startServer = async (createEngine, store = memory_1.createMemoryStore(), config = {}) => {
    const connectorUrl = config.connectorUrl || 'http://localhost:7771';
    const sendMessageUrl = config.sendMessageUrl || connectorUrl;
    const creditSettlementUrl = config.creditSettlementUrl || connectorUrl;
    const port = config.port ? +config.port : 3000;
    const services = {
        sendMessage: async (accountId, message) => {
            if (!store_1.isSafeKey(accountId)) {
                throw new Error(`Failed to send message: Invalid account: account=${accountId}`);
            }
            const accountExists = await store.isExistingAccount(accountId);
            if (!accountExists) {
                throw new Error(`Failed to send message: Account doesn't exist: account=${accountId}`);
            }
            const url = `${sendMessageUrl}/accounts/${accountId}/messages`;
            return axios_1.default
                .post(url, Buffer.from(JSON.stringify(message)), {
                timeout: 10000,
                headers: {
                    'Content-type': 'application/octet-stream'
                }
            })
                .then(response => response.data);
        },
        creditSettlement: async (accountId, amount, settlementId = v4_1.default()) => {
            let details = `amountToCredit=${amount} account=${accountId} settlementId=${settlementId}`;
            if (amount.isZero()) {
                return;
            }
            if (!quantity_1.isValidAmount(amount)) {
                return log(`Error: Failed to credit settlement, invalid amount: ${details}`);
            }
            if (!store_1.isSafeKey(accountId)) {
                return log(`Error: Failed to credit settlement, invalid account: ${details}`);
            }
            const accountExists = await store.isExistingAccount(accountId);
            if (!accountExists) {
                return log(`Error: Failed to credit settlement, account doesn't exist: ${details}`);
            }
            const uncreditedAmounts = await store
                .loadAmountToCredit(accountId)
                .then(amount => {
                if (!quantity_1.isValidAmount(amount)) {
                    throw new Error('Invalid uncredited amounts, database may be corrupted');
                }
                return amount;
            })
                .catch(err => {
                log(`Error: Failed to load uncredited settlement amounts: account=${accountId}`, err);
                return new bignumber_js_1.BigNumber(0);
            });
            if (uncreditedAmounts.isGreaterThan(0)) {
                log(`Loaded uncredited amount of ${uncreditedAmounts} to retry notifying connector`);
            }
            const amountToCredit = amount.plus(uncreditedAmounts);
            const scale = amountToCredit.decimalPlaces();
            const quantityToCredit = {
                scale,
                amount: amountToCredit.shiftedBy(scale).toFixed(0)
            };
            const notifySettlement = () => axios_1.default({
                method: 'POST',
                url: `${creditSettlementUrl}/accounts/${accountId}/settlements`,
                data: quantityToCredit,
                timeout: 10000,
                headers: {
                    'Idempotency-Key': settlementId
                }
            });
            details = `amountToCredit=${amountToCredit} account=${accountId} settlementId=${settlementId}`;
            log(`Notifying connector to credit settlement: ${details}`);
            const amountCredited = await retry_1.retryRequest(notifySettlement)
                .then(response => {
                if (quantity_1.isQuantity(response.data)) {
                    return quantity_1.fromQuantity(response.data);
                }
                log(`Error: Connector failed to process settlement: ${details}`);
                return new bignumber_js_1.BigNumber(0);
            })
                .catch(err => {
                if (err.response && quantity_1.isQuantity(err.response.data)) {
                    return quantity_1.fromQuantity(err.response.data);
                }
                log(`Error: Failed to credit incoming settlement: ${details}`, err);
                return new bignumber_js_1.BigNumber(0);
            });
            const leftoverAmount = amountToCredit.minus(amountCredited);
            details = `leftover=${leftoverAmount} credited=${amountCredited} amountToCredit=${amountToCredit} account=${accountId} settlementId=${settlementId}`;
            if (!quantity_1.isValidAmount(leftoverAmount)) {
                return log(`Error: Connector credited invalid amount: ${details}`);
            }
            log(`Connector credited incoming settlement: ${details}`);
            if (leftoverAmount.isZero()) {
                return;
            }
            await store
                .saveAmountToCredit(accountId, leftoverAmount)
                .catch(err => log(`Error: Failed to save uncredited settlement, balances incorrect: ${details}`, err));
        },
        trySettlement: async (accountId) => {
            let details = `account=${accountId}`;
            if (!engine) {
                return log(`Error: Engine must be connected before triggering settlment: ${details}`);
            }
            if (!store_1.isSafeKey(accountId)) {
                return log(`Error: Failed to settle, invalid account: ${details}`);
            }
            const amountToSettle = await store
                .loadAmountToSettle(accountId)
                .then(queuedAmount => {
                if (!quantity_1.isValidAmount(queuedAmount)) {
                    throw new Error('Invalid queued settlement amounts, database may be corrupted');
                }
                return queuedAmount;
            })
                .catch(err => {
                log(`Error: Failed to load amount queued for settlement: ${details}`, err);
                return new bignumber_js_1.BigNumber(0);
            });
            if (amountToSettle.isZero()) {
                return;
            }
            const amountSettled = await engine.settle(accountId, amountToSettle).catch(err => {
                log(`Settlement failed: amountToSettle=${amountToSettle} ${details}`, err);
                return amountToSettle;
            });
            const leftoverAmount = amountToSettle.minus(amountSettled);
            details = `leftover=${leftoverAmount} settled=${amountSettled} amountToSettle=${amountToSettle} account=${accountId}`;
            if (!quantity_1.isValidAmount(amountSettled)) {
                return log(`Error: Invalid settlement outcome: ${details}`);
            }
            if (!quantity_1.isValidAmount(leftoverAmount)) {
                return log(`Error: Settled too much: ${details}`);
            }
            log(`Settlement completed: ${details}`);
            if (leftoverAmount.isZero()) {
                return;
            }
            await store
                .saveAmountToSettle(accountId, leftoverAmount)
                .catch(err => log(`Error: Failed to save unsettled amount, balances incorrect: ${details}`, err));
        }
    };
    const engine = await createEngine(services);
    const { validateAccount, setupAccount, deleteAccount, settleAccount, handleMessage } = controllers_1.createController({
        engine,
        store,
        services
    });
    const app = express_1.default();
    app.post('/accounts', body_parser_1.default.json(), setupAccount);
    app.delete('/accounts/:id', validateAccount, deleteAccount);
    app.post('/accounts/:id/settlements', body_parser_1.default.json(), validateAccount, settleAccount);
    app.post('/accounts/:id/messages', body_parser_1.default.raw(), validateAccount, handleMessage);
    const server = app.listen(port);
    log('Started settlement engine server');
    return {
        async shutdown() {
            await new Promise(resolve => server.close(resolve));
            if (engine.disconnect) {
                await engine.disconnect();
            }
        }
    };
};
//# sourceMappingURL=index.js.map