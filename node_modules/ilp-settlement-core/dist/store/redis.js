"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ioredis_1 = __importDefault(require("ioredis"));
exports.connectRedis = async ({ client, uri, ...opts } = {}) => {
    const redis = client ? client : new ioredis_1.default(uri, opts);
    redis.defineCommand('deleteAccount', {
        numberOfKeys: 0,
        lua: `redis.call('SREM', 'accounts', ARGV[1])
          local pattern = 'accounts:' .. ARGV[1] .. '*'
          return redis.call('DEL', table.unpack(redis.call('KEYS', pattern)))`
    });
    redis.defineCommand('queueSettlement', {
        numberOfKeys: 0,
        lua: `-- Check for an existing idempotency key for this settlement
          local settlement_request_key = 'accounts:' .. ARGV[1] .. ':settlement-requests:' .. ARGV[2]
          local amount = redis.call('HGET', settlement_request_key, 'amount')

          -- If no idempotency key exists, cache idempotency key and enqueue the settlement
          if not amount then
            redis.call('HSET', settlement_request_key, 'amount', ARGV[3])
            amount = ARGV[3]

            local queued_settlements_key = 'accounts:' .. ARGV[1] .. ':queued-settlements'
            redis.call('LPUSH', queued_settlements_key, ARGV[3])
          end

          -- Set the timestamp of the most recent request for this idempotency key
          redis.call('HSET', settlement_request_key, 'last_request_timestamp', ARGV[4])

          -- Return amount queued for settlement (from preexisting idempotency key or this transaction)
          return amount`
    });
    const self = {
        async createAccount(accountId) {
            return (await redis.sadd('accounts', accountId)) === 0;
        },
        async isExistingAccount(accountId) {
            return (await redis.sismember('accounts', accountId)) === 1;
        },
        async deleteAccount(accountId) {
            await redis.deleteAccount(accountId);
        },
        async queueSettlement(accountId, idempotencyKey, amount) {
            return new bignumber_js_1.default(await redis.queueSettlement(accountId, idempotencyKey, amount.toString(), Date.now()));
        },
        async loadAmountToSettle(accountId) {
            return redis
                .multi()
                .lrange(`accounts:${accountId}:queued-settlements`, 0, -1)
                .del(`accounts:${accountId}:queued-settlements`)
                .exec()
                .then(async ([[err, res]]) => bignumber_js_1.default.sum(0, ...res));
        },
        async saveAmountToSettle(accountId, amount) {
            await redis.lpush(`accounts:${accountId}:queued-settlements`, amount.toString());
        },
        async loadAmountToCredit(accountId) {
            return redis
                .multi()
                .lrange(`accounts:${accountId}:uncredited-settlements`, 0, -1)
                .del(`accounts:${accountId}:uncredited-settlements`)
                .exec()
                .then(([[, res]]) => bignumber_js_1.default.sum(0, ...res));
        },
        async saveAmountToCredit(accountId, amount) {
            await redis.lpush(`accounts:${accountId}:uncredited-settlements`, amount.toString());
        },
        async disconnect() {
            redis.disconnect();
        }
    };
    return self;
};
//# sourceMappingURL=redis.js.map