"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const util_1 = require("util");
const log = debug_1.default('settlement-core');
exports.sleep = (ms) => new Promise(r => setTimeout(r, ms));
exports.generateRandom = async () => (await util_1.promisify(crypto_1.randomBytes)(4)).readUInt32BE(0) / 4294967296;
const RETRY_MIN_DELAY_MS = 100;
const RETRY_MAX_DELAY_MS = 1000 * 60 * 60;
exports.retryRequest = (performRequest, attempt = 1) => performRequest().catch(async (err) => {
    const is409 = err.response && err.response.code === 409;
    const is5xx = err.response && err.response.code >= 500;
    const noResponse = err.request && !err.response;
    const shouldRetry = is409 || is5xx || noResponse;
    if (!shouldRetry) {
        throw err;
    }
    let delayMs = Math.min(RETRY_MIN_DELAY_MS * 2 ** (attempt - 1), RETRY_MAX_DELAY_MS);
    delayMs = delayMs * (0.5 * (1 + (await exports.generateRandom())));
    delayMs = Math.max(RETRY_MIN_DELAY_MS, delayMs);
    log(`Retrying HTTP request in ${Math.floor(delayMs / 1000)} seconds:`, err.message);
    await exports.sleep(delayMs);
    return exports.retryRequest(performRequest, attempt + 1);
});
//# sourceMappingURL=retry.js.map